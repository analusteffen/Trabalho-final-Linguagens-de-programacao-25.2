#include <iostream>
#include <vector>
#include <set>
#include <algorithm> // para sort, lower_bound
#include <iterator>
#include <chrono>    // para medir o tempo
#include <cmath>     // para infinity
#include <iomanip>

using namespace std;

// --- Interface Abstrata (Define o que todo "Banco de Sensores" deve ter) ---
class SensorDatabase {
public:
    virtual void insert(double value) = 0;
    virtual void remove(double value) = 0;
    virtual void printSorted() = 0;
    virtual void getMinMax(int k) = 0; // Ex: 3 menores e 3 maiores
    virtual void rangeQuery(double minVal, double maxVal) = 0;
    virtual double median() = 0;
    virtual string getName() = 0; // Para identificar nos testes
    virtual ~SensorDatabase() {}
};

// --- IMPLEMENTAÇÃO 1: Versão Básica (Lista Ordenada / Insertion Sort) ---
// Inserção lenta O(N), Leitura rápida O(1)
class ListaOrdenada : public SensorDatabase {
private:
    vector<double> dados;

public:
    string getName() override { return "Versao Basica (Vector)"; }

    void insert(double value) override {
        // Encontra a posição correta para manter ordenado (Busca Binária)
        auto it = lower_bound(dados.begin(), dados.end(), value);
        // Insere o valor (Isso é LENTO pois desloca todos os elementos à frente)
        dados.insert(it, value);
    }

    void remove(double value) override {
        auto it = lower_bound(dados.begin(), dados.end(), value);
        if (it != dados.end() && *it == value) {
            dados.erase(it); // Também lento, desloca elementos
        }
    }

    void printSorted() override {
        // Já está ordenado
        // for (double v : dados) cout << v << " "; cout << endl; // Comentado para não poluir testes grandes
    }

    void getMinMax(int k) override {
        if (dados.empty()) return;
        int n = dados.size();
        k = min(k, n);
        
        // Acesso direto O(1)
        // cout << "Minimos: ";
        // for(int i=0; i<k; i++) cout << dados[i] << " ";
        // cout << " | Maximos: ";
        // for(int i=0; i<k; i++) cout << dados[n-1-i] << " ";
        // cout << endl;
    }

    void rangeQuery(double minVal, double maxVal) override {
        auto itStart = lower_bound(dados.begin(), dados.end(), minVal);
        auto itEnd = upper_bound(dados.begin(), dados.end(), maxVal);
        
        // Apenas itera sobre os elementos no intervalo
        int count = 0;
        for (auto it = itStart; it != itEnd; ++it) {
            count++; // Apenas contando para teste de performance
        }
    }

    double median() override {
        if (dados.empty()) return 0.0;
        if (dados.size() % 2 == 0) {
            return (dados[dados.size()/2 - 1] + dados[dados.size()/2]) / 2.0;
        } else {
            return dados[dados.size()/2];
        }
    }
};

// --- IMPLEMENTAÇÃO 2: Versão Aprimorada (Árvore Balanceada) ---
// Inserção rápida O(log N), Remoção rápida O(log N)
class ArvoreBalanceada : public SensorDatabase {
private:
    // multiset permite valores duplicados e mantém ordenação automática (Árvore Rubro-Negra)
    multiset<double> dados; 

public:
    string getName() override { return "Versao Aprimorada (Tree/Multiset)"; }

    void insert(double value) override {
        dados.insert(value); // O(log N) - Muito mais rápido
    }

    void remove(double value) override {
        auto it = dados.find(value);
        if (it != dados.end()) {
            dados.erase(it); // O(log N)
        }
    }

    void printSorted() override {
        // Em-ordem (in-order traversal) implícito
        // for (double v : dados) cout << v << " "; cout << endl;
    }

    void getMinMax(int k) override {
        if (dados.empty()) return;
        int n = dados.size();
        k = min(k, n);

        // Iteradores bidirecionais
        // auto it = dados.begin();
        // cout << "Minimos: ";
        // for(int i=0; i<k; i++) cout << *it++ << " ";
        
        // auto rit = dados.rbegin();
        // cout << " | Maximos: ";
        // for(int i=0; i<k; i++) cout << *rit++ << " ";
        // cout << endl;
    }

    void rangeQuery(double minVal, double maxVal) override {
        // Busca o início e fim do intervalo em O(log N)
        auto itStart = dados.lower_bound(minVal);
        auto itEnd = dados.upper_bound(maxVal);

        int count = 0;
        for (auto it = itStart; it != itEnd; ++it) {
            count++;
        }
    }

    double median() override {
        if (dados.empty()) return 0.0;
        size_t size = dados.size();
        auto it = dados.begin();
        
        // Ponto de atenção: Em std::multiset, chegar ao meio custa O(N/2)
        // Para O(log N) real, seria necessário implementar uma AVL manual com contagem de nós.
        // Mas para este exercício, a vantagem na inserção compensa.
        std::advance(it, size / 2);
        
        if (size % 2 != 0) {
            return *it;
        } else {
            double val1 = *it;
            std::advance(it, -1); // volta um
            double val2 = *it;
            return (val1 + val2) / 2.0;
        }
    }
};

// --- FUNÇÃO AUXILIAR PARA TESTE DE PERFORMANCE ---
void runBenchmark(SensorDatabase* db, int dataSize) {
    // Gerar dados aleatórios
    vector<double> inputData;
    inputData.reserve(dataSize);
    for(int i=0; i<dataSize; i++) {
        inputData.push_back((rand() % 10000) / 10.0); // Temps entre 0.0 e 1000.0
    }

    cout << "--- Testando " << db->getName() << " com " << dataSize << " elementos ---" << endl;

    // 1. Medir Tempo de Inserção
    auto start = chrono::high_resolution_clock::now();
    for (double v : inputData) {
        db->insert(v);
    }
    auto end = chrono::high_resolution_clock::now();
    chrono::duration<double> diff = end - start;
    cout << "Insercao: " << fixed << setprecision(4) << diff.count() << " s" << endl;

    // 2. Medir Range Query (Consulta)
    start = chrono::high_resolution_clock::now();
    for(int i=0; i<1000; i++) { // Executa 1000 consultas
        db->rangeQuery(200.0, 500.0); 
    }
    end = chrono::high_resolution_clock::now();
    diff = end - start;
    cout << "1000 Consultas (Range): " << diff.count() << " s" << endl;

    // 3. Medir Mediana
    start = chrono::high_resolution_clock::now();
    volatile double m = db->median(); // volatile para o compilador não otimizar
    end = chrono::high_resolution_clock::now();
    diff = end - start;
    cout << "Calculo da Mediana: " << diff.count() << " s" << endl;

    cout << "------------------------------------------------" << endl;
}

int main() {
    // Configura semente aleatória
    srand(time(0));

    // Define tamanhos de teste: Pequeno, Médio, Grande
    vector<int> tamanhos = {1000, 10000, 50000}; 
    // OBS: 50.000 na lista ordenada já vai demorar alguns segundos.
    // 100.000 ou mais pode travar a Lista Ordenada por muito tempo.

    for (int n : tamanhos) {
        ListaOrdenada* lista = new ListaOrdenada();
        ArvoreBalanceada* arvore = new ArvoreBalanceada();

        runBenchmark(lista, n);
        runBenchmark(arvore, n);

        delete lista;
        delete arvore;
    }

    return 0;
}
